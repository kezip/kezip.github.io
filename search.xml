<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP常见状态码(200、400、404、500)等错误分析详情]]></title>
    <url>%2F2017%2F10%2F14%2FHTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81-200%E3%80%81400%E3%80%81404%E3%80%81500-%E7%AD%89%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90%E8%AF%A6%E6%83%85%2F</url>
    <content type="text"><![CDATA[常见的HTTP状态码HTTP状态码，它是用以表示网页服务器HTTP响应状态的3位数字代码。状态码的第一个数字代表了响应的五种状态之一。 一些常见的状态码： 200—服务器成功返回网页 404— 请求的网页不存在 503— 服务不可用 1xx (临时响应)1····························································· 表示临时响应并需要请求者继续执行操作的状态代码。 代码说明： 100—(继续) 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101—(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx (成功)1............................................................. 表示成功处理了请求的状态代码。 代码说明： 200— (成功) 服务器已成功处理了请求。通常这表示服务器提供了请求的网页。 201— (已创建) 请求成功并且服务器创建了新的资源。 202— (已接受) 服务器已接受请求，但尚未处理。 203— (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204— (无内容) 服务器成功处理了请求，但没有返回任何内容。 205— (重置内容) 服务器成功处理了请求，但没有返回任何内容。 206— (部分内容) 服务器成功处理了部分get请求。 3xx (重定向)1............................................................. 表示要完成请求，需要进一步操作。通常这些状态码用来重定向。 代码说明： 300— (多种选择) 针对请求，服务器可执行多种操作。服务器可根据请求者(user agent)选择一项操作，或提供操作列表请求者选择。 301— (永久移动) 请求的网页已永久移动到新位置。服务器返回此响应(对get或head请求的响应)时，会自动将请求者转到新位置。 302— (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303— (查看其它位置) 请求者应当对不同的位置使用单独的get请求来检索响应时，服务器返回此代码。 304— (未修改) 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305— (使用代理) 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307— (临时重定向) 服务器目前从不同位置的网页访响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx (请求错误)1............................................................. 这些状态码表示请求可能出错，妨碍了服务器的处理。 代码说明： 400— (错误请求) 服务器不理解请求的语法。 401— (未授权) 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。 403— (禁止) 服务器拒绝请求。 404— (未找到) 服务器找不到请求的网页。 405— (方法禁用) 禁用请求中指定的方法。 406— (不接受) 无法使用请求的内容特性响应请求的网页。 407— (需要代理授权) 此状态代码与401(未授权) 类似，但指定请求者应当授权使用代理。 408— (请求超时) 服务器等候请求时发生超时。 409— (冲突) 服务器在完成请求发生冲突。服务器必须在响应中包含有关冲突的信息。 410— (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411— (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412— (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413— (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414— (请求的url过长) 请求的URL(通常为网址) 过长，服务器无法处理。 415— (不支持的媒体类型) 请求的格式不受请求页面的支持。 416— (请求范围不符合要求) 如果页面无法提供请求的范围则服务器会返回此状态代码。 417— (未满足期望值) 服务器未满足“期望”请求标头字段的要求。 5xx (服务器错误)1............................................................. 这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 代码说明： 500— (服务器内部错误) 服务器遇到错误，无法完成请求。 501— (尚未实施) 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502— (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503— (服务不可用) 服务器目前无法使用(由于超载或停机维护)。通常这只是暂时状态。 504— (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505— (HTTP版本不受支持) 服务器不支持请求中所用的HTTP协议版本。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp的安装和简单使用]]></title>
    <url>%2F2017%2F09%2F23%2Fgulp%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[gulp123456789多个开发者共同开发一个项目，每位开发者负责不同的模块，这就会造成一个完整的项目实际上是由许多的“代码版段”组成的；使用less、sass等一些预处理程序，降低CSS的维护成本，最终需要将这些预处理程序进行解析；合并css、javascript，压缩html、css、javascript、images可以加速网页打开速度，提升性能；这一系列的任务完全靠手动完成几乎是不可能的，借助构建工具可以轻松实现。所谓构建工具是指通过简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack 1. gulp简介 gulp这个软件是用nodejs写的. gulp是基于流的自动化构建工具 网站开发完成之后,我们要做项目构建,完成之后才可以上线. 项目构建: 代码压缩.html css js 代码混淆 文件合并 等其它自动化工作. sass转换为css. 这就是gulp做的事情. 2. gulp安装 首先需要全局安装gulp,如果之前已经全局安装过,可以省略这步. 123456npm install gulp -g global 全局安装. 会把该软件安装到系统目录中.我们使用npm下载插件,实际上是从https://www.npmjs.com/下载.全局安装的插件 可以在任意的地方使用.本地安装的插件 只能在当前项目中使用.使用gulp -v命令查看安装的gulp版本 如果可以看到就说明安装成功. 还需要本地安装,在项目目录中. 1npm install gulp --save 3. gulp使用 在项目目录中新建1个gulpfile.js文件. 在这个文件中写上构建代码. 先引入本地的gulp模块 12var gulp = require('gulp');//这个gulp对象就可以配合插件来进行构建工作. 3.1 创建任务 gulp是以任务的形式来执行每一项构建化工作. 调用gulp对象的task方法可以创建任务 参数1: 任务名称 参数2: 回调函数,执行该任务的时候,要做的事情. 123gulp.task("testTask",function()&#123; console.log();&#125;); 这个时候,我们就创建了1个任务testTask,该任务做的事情就是回调函数的事情. 3.2 执行任务 如何执行这个gulp任务呢? 打开cmd工具,切换工作路径到项目目录 在命令行窗口中使用gulp 任务名称就可以执行指定的任务. 1gulp testTask 这个时候,名叫testTask的任务就会被执行. 4.压缩CSS gulp-cssmin 需要创建1个压缩css的任务. 12345678910111213141516var cssmin = require("gulp-cssmin");gulp.task("yscss",function () &#123; //1.这个任务是用来压缩css的. // 那么首先你需要指定需要压缩的css文件 // 调用gulp对象的src方法,指定要处理的文件的路径. gulp.src("./src/assets/css/reset.css") .pipe(cssmin()) .pipe(gulp.dest("./dist/assets/css")); //2.pipe()管道理解 阀门形象理解. //3.管道中每一个阀门做不同的事情.不同的事情需要插件来完成. // 压缩css的插件. gulp-cssmin // 安装插件,引入gulp-cssmin // 引入后,其实1个函数. // 将其在管道中调用,相当于在管道中设置了1个阀门. //4.管道最后1关,要调用gulp对象的dest方法,设置存放处理后的路径.&#125;); 5.文件监视 watch gulp对象提供了一个watch方法 该方法的作用,监视指定文件的变化, 一旦改动,就执行指定的任务 1234gulp.task("watchCss",function () &#123; //监视指定的css文件.可以使用通配符,一旦文件发送变化,就自动执行yscss任务 gulp.watch("./src/assets/css/reset.css",["yscss"]);&#125;) watch方法的第2个参数,还可以是1个回调.当文件发生变化以后,就执行这个回调. 5.gulp-uglify 压缩js 压缩混淆js代码,需要gulp-uglify插件支持.使用npm安装该插件. 12345678910//1.引入gulp模块var gulp = require("gulp");//2.引入gulp-uglify模块.返回的是1个函数.var uglify = require("gulp-uglify");//3.新建任务gulp.task("ysjs",function()&#123; gulp.src("./js/app.js") .pipe(uglify()) .pipe(gulp.dest("./dist/js"));&#125;); 6.gulp-concat 合并文件 文件合并需要使用到 gulp-concat插件支持.使用npm安装该插件. 123456gulp.task("concatFile",function()&#123; gulp.src(["./src/js/app.js","./src/js/demo.js"]) .pipe(concat("all.js"))//将待处理的文件进行合并,合并后的新文件的名称为 all.js .pipe(uglify())//再混淆 .pipe(gulp.dest("./dist/js"));&#125;); 7.gulp-htmlmin 压缩html文件 压缩html代码需要使用到 gulp-htmlmin插件支持.使用npm安装该插件. 12345678gulp.task("yshtml",function()&#123; gulp.src("./src/index.html") .pipe(htmlmin(&#123; collapseWhitespace:true, //去空格 removeComments:true//去注释 &#125;)) .pipe(gulp.dest("./dist"))&#125;); 8.gulp-sass 将sass转换为 css123456gulp.task("sass2css",function()&#123; gulp.src("./src/css/index.scss") .pipe(sass()) .pipe(cssmin()) .pipe(gulp.dest("./dist/css"));&#125;); 9. gulp-less 将less转换为 css10. gulp-imagemin 压缩图片]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>自动化构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
