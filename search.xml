<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js基础--函数]]></title>
    <url>%2F2017%2F10%2F22%2Fjs%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、函数1.1函数声明js中可以通过以下三种方法定义函数：a.自定义函数b.直接量声明(函数式表达式声明)12345678910111213使用Function函数构造法(参数必须加引号)。区别： 自定义函数和直接量声明是有区别的，自定义函数调用在定义之前之后都是可以的；而直接量声明只能在声明函数之后调用，否则会报错(像下面的fun2就会报错)： //1.自定义函数 function fun1()&#123;alert(&apos;这是自定义函数&apos;);&#125; //函数声明之后需要调用，不然不会自动执行，执行函数可以在声明之后。//fun1(); //2.直接量声明 fun2(); //调用函数 var fun2 = function()&#123;alert(&apos;这是直接量声明&apos;);&#125; //3.使用Function关键字 var fun3 = new Function(&apos;var a = 10,b = 20;alert(a+b);&apos;); fun3(); 1.2变量提升变量提升指的是在函数体内会把变量的声明提升到函数的最前面 ，只声明但是并不给变量赋值。例如：1234567891011121314151617181920function fun()&#123; console.log(num); var num = 20;&#125;;//相当于：function fun()&#123; var num; console.log(num); num = 20;&#125;;//所以结果，这里会报undefined的异常。//下面的输出结果是undefined和20，就是执行了变量提升，尽管前面声明了num,但是在函数里面先声明num,而没有给赋值。var num = 10;function fun1()&#123; alert(num); var num = 20; alert(num);&#125;;fun1();//调用函数 1.3函数参数a.在创建函数的同时会创建一个arguments对象用来存储函数调用是传过来的实参，arguments对象的长度由传过来的个数决定。函数名.length可以获取函数形参的个数。根据这一方法可以判断实参和形参个数是否相同。函数实参个数多于形参个数可以调用，小于则会报错(相当于一个形参undefined)123456function fun(a,b)&#123; console.log(a+b);&#125;;fun(2,3);//5fun(6);//NaNfun(3,4,5)//7 b.下面判断形参和实参个数123456789function fun(a,b)&#123; if(fun.length == argruments.length)&#123; console.log(a+b); &#125;else&#123; console.error(&apos;传递的参数不匹配&apos;); &#125;;&#125;;fun(2,3);//5fun(2,3,4)//传递参数不匹配 1.4两种定义变量的区别123var a = 1,b = 1;var a = b = 1;//前者相当于var a = 1;var b = 1;两个变量均是局部变量。而后一个是a是局部变量，b则是全局变量(隐式的全局变量)。var a = 1和a = 1前者如果是在函数内声明属于全局变量，后者跟上面说的一样，属于隐式的全局变量。 1.5 returnreturn有两个作用：一是设置返回值，另一个是终止代码的执行。在函数内部使用return来设置返回值，一个函数只能有一个返回值，自定义的函数默认没有返回值。同时return后跟逗号可以终止代码的执行(比如提交表单之前的校验)。1234567function fun(a,b)&#123; if(a&gt;b)&#123; return;//如果后面直接跟分号，是终止当前函数的执行。 &#125; return a+b;&#125;console.log(fun(3,5)); 1.6 ++运算i++: 先使用i,执行完再运算 i= i+1；++i先执行i=i+1,然后在执行运算。12345var a = 10,b = 20,c = 30;++a;a++;e = ++a+(++b)+(c++)+a++;alert(e);//77 1.7 thisthis自己的，主要指事件的调用者。innerHTML更换盒子的内容value获取和设置表单的的值，下面说一个小技巧，页面加载完毕之后自动获取焦点(例如百度搜索)，鼠标滑过之后自动选中文本内容，便于用户删除搜索框的内容dom.focus()获取dom焦点,onfocus()获取焦点触发事件，dom.select()选中dom。12345678910111213141516171819202122&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;两个表单小方法&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; //页面加载完毕自动获取焦点 var focus = document.getElementById(&quot;focus&quot;); focus.focus(); //鼠标经过自动选中文本内容，方便用户删除 var sel = document.getElementById(&quot;sel&quot;); sel.onmouseover = function()&#123; this.select(); //this指事件调用者 &#125;; &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;test&quot; id=&quot;focus&quot;&gt; &lt;br&gt; &lt;input type=&quot;test&quot; id=&quot;sel&quot;&gt;&lt;/body&gt; 1.8输入框表单校验(基本的表单校验)123456789101112131415161718192021222324252627282930&lt;script&gt; window.onload = function()&#123; var tet = document.getElementById(&apos;name&apos;); tet.onfocus = function()&#123; //清空this.value = &quot;&quot;; &#125; //失去焦点判断输入内容 tet.onblur = fucntion()&#123; if(this.value == &quot;&quot;)&#123; this.value = &quot;请输入。。。。。&quot;; &#125; &#125; document.gtElementsTagName(&apos;button&apos;)[0].onclick = function()&#123; if(tet.value == &quot;&quot; || tet.value == &quot;请输入....&quot;)&#123; tet.value = &quot;请输入....&quot;; alert(&quot;请输入内容&quot;); return; //终止执行代码继续向下执行 &#125; alert(&quot;正在搜索，请稍后&quot;); &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;请输入...&quot; id=&quot;name&quot;&gt; &lt;button&gt;&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 1.9金字塔在页面输出一个金字塔的形状，可以使用for循环,使用百分比来控制hr的宽度。1234567&lt;script&gt; for(i=1;i&lt;=100;i++)&#123; document.write(&apos;&lt;hr wridth=&apos;+i+&apos;%&gt;&apos;); &#125;&lt;/script&gt;&lt;body&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript基础 函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发企业级css常用命名，书写规范总结]]></title>
    <url>%2F2017%2F10%2F22%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BC%81%E4%B8%9A%E7%BA%A7css%E5%B8%B8%E7%94%A8%E5%91%BD%E5%90%8D%EF%BC%8C%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、css常用命名规范1、常用命名 12345678910111213141516171819202122232425262728293031323334353637标题：title摘要：summary箭头：arrow商标：label网站标志：logo转角/圆角：corner横幅广告：banner子菜单：subMenu搜索：search搜索框：searchBox登录：login登录条：loginbar工具条：toolbar下拉：drop标签页：tab当前页：current列表：list滚动：scroll服务：service提示信息：msg热点：hot新闻：news小技巧：tips下载：download栏目标题：title加入：joinus注册：regsiter指南：guide友情链接：friendlink状态：status版权：copyright按钮：btn合作伙伴：partner投票：vote左/右/中：left/right/center简介：profiles评论：comment 2、ID命名(1)页面结构 12345678910容器：container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidear栏目：column页面外围控制整体布局宽度：wrapper左/右/中：left/right/center (2)导航 1234567891011导航：nav主导航：mainbav子导航：subnav顶导航：topnav边导航：sidebar左导航：leftsidebar右导航：rightsidebar菜单：menu子菜单：submenu标题：title摘要：summary (3)功能 12345678910111213141516171819202122232425262728标志：logo广告：banner登录：login登录条：loginbar注册：regsiter搜索：search功能区：shop标题：title加入：joinus状态：status按钮：btn滚动：scroll标签页：tab文章列表：list提示信息：msg当前的：current小技巧：tips图标：icon注释：note指南：guild服务：service热点：hot新闻：news下载：download投票：vote合作伙伴：partner友情链接：link版权：copyright 3、class命名(1)颜色：使用颜色的名称或者16进制代码，如： 123.red&#123;color:red;&#125;.f60&#123;color:#60;&#125;.ff8600&#123;color:#ff8600;&#125; (2)字体大小：直接使用“font+字体大小”作为名称，如： 12.font12px&#123;font-size:12px;&#125;.font9pt&#123;font-size:9pt;&#125; (3)对齐样式：使用对齐目标的英文名称，如： 12.left&#123;float:left;&#125;.bottom&#123;float:bottom;&#125; (4)标题栏样式：使用”类别+功能”的方式命名，如： 12.barnews&#123;&#125;.barproduct&#123;&#125; 二、推荐的css书写顺序—–相关的属性声明应当归为一组，并按照下面的顺序排列：1234PositioningBox modelTypographicVisual —–由于定位(positioning)可以从正常的文档流中移除元素，并且还能覆盖盒模型(box model)相关的样式，因此排在首位。盒模型排在第二位，因为它决定了组件的尺寸和位置。1234567891011121314151617181920212223242526xxx&#123; /*Positioning*/ position:absolute; top:0; right:0; bottom:0; left:0; z-index:100; /*Box model*/ dispaly:block; float:right; width:100px; height:120px; /*Typography*/ font:normal 16px &quot;Helvetica Neue&quot;,sans-serif; line-height:1.5; color: #ccc; text-align:center; /*Visual*/ background-color:#009480; border:1px solid skybule; border-radius: 5px;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>css常用命名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决端口占用的方法：Error:listen EADDRINUSE]]></title>
    <url>%2F2017%2F10%2F20%2F%E8%A7%A3%E5%86%B3%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9AError-listen-EADDRINUSE%2F</url>
    <content type="text"><![CDATA[《问题描述》在进行代码调试时，很容易出现端口占用的情况。——-解决方法： 12341.在命令行中输入：netsat -aon|findstr &quot;xxxx&quot;,如(8080)找到端口号监听的位置。查看是否有程序占用端口。2.再输入tasklist|findstr &quot;xxxx&quot; 如(1884),显示，node.exe占用了端口。3.ok，接下来找到进程，把node进程结束，关掉控制台。4.然后重新运行即可解决。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>端口被占用 常见端口占用的问题 端口占用的解决方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除node_modules文件夹，解决目录层次太深删除报错的问题]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%88%A0%E9%99%A4node-modules%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E8%A7%A3%E5%86%B3%E7%9B%AE%E5%BD%95%E5%B1%82%E6%AC%A1%E5%A4%AA%E6%B7%B1%E5%88%A0%E9%99%A4%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述在使用gulp中，自动生成的node_modules文件夹，因为文件目录太深，无法系统删除，报错。 解决办法： 121. 安装：npm install rimraf -g (全局安装)2. 使用：先定位到目标文件夹的父级目录，然后在命令行输入：rimraf node_modules(也就是目标文件夹) 示例如下：]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>gulp使用技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP常见状态码(200、400、404、500)等错误分析详情]]></title>
    <url>%2F2017%2F10%2F14%2FHTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81-200%E3%80%81400%E3%80%81404%E3%80%81500-%E7%AD%89%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90%E8%AF%A6%E6%83%85%2F</url>
    <content type="text"><![CDATA[常见的HTTP状态码1HTTP状态码，它是用以表示网页服务器HTTP响应状态的3位数字代码。状态码的第一个数字代表了响应的五种状态之一。 一些常见的状态码： 200—服务器成功返回网页 404— 请求的网页不存在 503— 服务不可用 1xx (临时响应) 1····························································· 表示临时响应并需要请求者继续执行操作的状态代码。 代码说明： 100—(继续) 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101—(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx (成功)1............................................................. 表示成功处理了请求的状态代码。 代码说明： 200— (成功) 服务器已成功处理了请求。通常这表示服务器提供了请求的网页。 201— (已创建) 请求成功并且服务器创建了新的资源。 202— (已接受) 服务器已接受请求，但尚未处理。 203— (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204— (无内容) 服务器成功处理了请求，但没有返回任何内容。 205— (重置内容) 服务器成功处理了请求，但没有返回任何内容。 206— (部分内容) 服务器成功处理了部分get请求。 3xx (重定向)1............................................................. 表示要完成请求，需要进一步操作。通常这些状态码用来重定向。 代码说明： 300— (多种选择) 针对请求，服务器可执行多种操作。服务器可根据请求者(user agent)选择一项操作，或提供操作列表请求者选择。 301— (永久移动) 请求的网页已永久移动到新位置。服务器返回此响应(对get或head请求的响应)时，会自动将请求者转到新位置。 302— (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303— (查看其它位置) 请求者应当对不同的位置使用单独的get请求来检索响应时，服务器返回此代码。 304— (未修改) 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305— (使用代理) 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307— (临时重定向) 服务器目前从不同位置的网页访响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx (请求错误)1............................................................. 这些状态码表示请求可能出错，妨碍了服务器的处理。 代码说明： 400— (错误请求) 服务器不理解请求的语法。 401— (未授权) 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。 403— (禁止) 服务器拒绝请求。 404— (未找到) 服务器找不到请求的网页。 405— (方法禁用) 禁用请求中指定的方法。 406— (不接受) 无法使用请求的内容特性响应请求的网页。 407— (需要代理授权) 此状态代码与401(未授权) 类似，但指定请求者应当授权使用代理。 408— (请求超时) 服务器等候请求时发生超时。 409— (冲突) 服务器在完成请求发生冲突。服务器必须在响应中包含有关冲突的信息。 410— (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411— (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412— (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413— (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414— (请求的url过长) 请求的URL(通常为网址) 过长，服务器无法处理。 415— (不支持的媒体类型) 请求的格式不受请求页面的支持。 416— (请求范围不符合要求) 如果页面无法提供请求的范围则服务器会返回此状态代码。 417— (未满足期望值) 服务器未满足“期望”请求标头字段的要求。 5xx (服务器错误)1............................................................. 这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 代码说明： 500— (服务器内部错误) 服务器遇到错误，无法完成请求。 501— (尚未实施) 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502— (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503— (服务不可用) 服务器目前无法使用(由于超载或停机维护)。通常这只是暂时状态。 504— (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505— (HTTP版本不受支持) 服务器不支持请求中所用的HTTP协议版本。]]></content>
      <categories>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>HTTP状态码 404错误 服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp的安装和简单使用]]></title>
    <url>%2F2017%2F09%2F23%2Fgulp%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[gulp123456789多个开发者共同开发一个项目，每位开发者负责不同的模块，这就会造成一个完整的项目实际上是由许多的“代码版段”组成的；使用less、sass等一些预处理程序，降低CSS的维护成本，最终需要将这些预处理程序进行解析；合并css、javascript，压缩html、css、javascript、images可以加速网页打开速度，提升性能；这一系列的任务完全靠手动完成几乎是不可能的，借助构建工具可以轻松实现。所谓构建工具是指通过简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack 1. gulp简介 gulp这个软件是用nodejs写的. gulp是基于流的自动化构建工具 网站开发完成之后,我们要做项目构建,完成之后才可以上线. 项目构建: 代码压缩.html css js 代码混淆 文件合并 等其它自动化工作. sass转换为css. 这就是gulp做的事情. 2. gulp安装 首先需要全局安装gulp,如果之前已经全局安装过,可以省略这步. 123456npm install gulp -g global 全局安装. 会把该软件安装到系统目录中.我们使用npm下载插件,实际上是从https://www.npmjs.com/下载.全局安装的插件 可以在任意的地方使用.本地安装的插件 只能在当前项目中使用.使用gulp -v命令查看安装的gulp版本 如果可以看到就说明安装成功. 还需要本地安装,在项目目录中. 1npm install gulp --save 3. gulp使用 在项目目录中新建1个gulpfile.js文件. 在这个文件中写上构建代码. 先引入本地的gulp模块 12var gulp = require('gulp');//这个gulp对象就可以配合插件来进行构建工作. 3.1 创建任务 gulp是以任务的形式来执行每一项构建化工作. 调用gulp对象的task方法可以创建任务 参数1: 任务名称 参数2: 回调函数,执行该任务的时候,要做的事情. 123gulp.task("testTask",function()&#123; console.log();&#125;); 这个时候,我们就创建了1个任务testTask,该任务做的事情就是回调函数的事情. 3.2 执行任务 如何执行这个gulp任务呢? 打开cmd工具,切换工作路径到项目目录 在命令行窗口中使用gulp 任务名称就可以执行指定的任务. 1gulp testTask 这个时候,名叫testTask的任务就会被执行. 4.压缩CSS gulp-cssmin 需要创建1个压缩css的任务. 12345678910111213141516var cssmin = require("gulp-cssmin");gulp.task("yscss",function () &#123; //1.这个任务是用来压缩css的. // 那么首先你需要指定需要压缩的css文件 // 调用gulp对象的src方法,指定要处理的文件的路径. gulp.src("./src/assets/css/reset.css") .pipe(cssmin()) .pipe(gulp.dest("./dist/assets/css")); //2.pipe()管道理解 阀门形象理解. //3.管道中每一个阀门做不同的事情.不同的事情需要插件来完成. // 压缩css的插件. gulp-cssmin // 安装插件,引入gulp-cssmin // 引入后,其实1个函数. // 将其在管道中调用,相当于在管道中设置了1个阀门. //4.管道最后1关,要调用gulp对象的dest方法,设置存放处理后的路径.&#125;); 5.文件监视 watch gulp对象提供了一个watch方法 该方法的作用,监视指定文件的变化, 一旦改动,就执行指定的任务 1234gulp.task("watchCss",function () &#123; //监视指定的css文件.可以使用通配符,一旦文件发送变化,就自动执行yscss任务 gulp.watch("./src/assets/css/reset.css",["yscss"]);&#125;) watch方法的第2个参数,还可以是1个回调.当文件发生变化以后,就执行这个回调. 5.gulp-uglify 压缩js 压缩混淆js代码,需要gulp-uglify插件支持.使用npm安装该插件. 12345678910//1.引入gulp模块var gulp = require("gulp");//2.引入gulp-uglify模块.返回的是1个函数.var uglify = require("gulp-uglify");//3.新建任务gulp.task("ysjs",function()&#123; gulp.src("./js/app.js") .pipe(uglify()) .pipe(gulp.dest("./dist/js"));&#125;); 6.gulp-concat 合并文件 文件合并需要使用到 gulp-concat插件支持.使用npm安装该插件. 123456gulp.task("concatFile",function()&#123; gulp.src(["./src/js/app.js","./src/js/demo.js"]) .pipe(concat("all.js"))//将待处理的文件进行合并,合并后的新文件的名称为 all.js .pipe(uglify())//再混淆 .pipe(gulp.dest("./dist/js"));&#125;); 7.gulp-htmlmin 压缩html文件 压缩html代码需要使用到 gulp-htmlmin插件支持.使用npm安装该插件. 12345678gulp.task("yshtml",function()&#123; gulp.src("./src/index.html") .pipe(htmlmin(&#123; collapseWhitespace:true, //去空格 removeComments:true//去注释 &#125;)) .pipe(gulp.dest("./dist"))&#125;); 8.gulp-sass 将sass转换为 css123456gulp.task("sass2css",function()&#123; gulp.src("./src/css/index.scss") .pipe(sass()) .pipe(cssmin()) .pipe(gulp.dest("./dist/css"));&#125;); 9. gulp-less 将less转换为 css10. gulp-imagemin 压缩图片]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>自动化构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
